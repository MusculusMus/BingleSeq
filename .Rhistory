countData = output2,
colData = coldata,
design =  ~ samplescondition
)
if(testType == "Wald"){
dds <- DESeq(dds, test = "Wald", fitType = fitType)
} else if(testType == "LRT"){
dds = DESeq(dds, test = "LRT", reduced =  ~ 1, fitType = fitType)
}
res <-  results(dds)
DEData <- data.frame(as.data.frame(res))
DEData.matching <- DEData[, c(2, 4:6)]
colnames(DEData.matching) <- c("logFC", "stat", "Pvalue", "FDR")
normCounts <- as.data.frame(counts(dds, normalized = TRUE))
deList <- list(DEData.matching, normCounts)
return(deList)
}
deEdgeR <- function(readCounts, meta, testType, normMethod){
## 1. Load and Format Count dataframe
countTable  <- readCounts[, -1]
rownames(countTable) <- readCounts[, 1]
## 2. Assign Condition Groups
samplescondition <- factor(meta$treatment)
## 3. Norm and Disp
dge  <- DGEList(countTable, group = samplescondition)
# Calculate normalization factors to scale the raw library sizes
dge = calcNormFactors(dge, method = normMethod)
# Estimate Common and Tagwise Dispersion
dge = estimateCommonDisp(dge)
dge = estimateTagwiseDisp(dge)
## 4. DE
if(testType == "exact"){
de = exactTest(dge)
}else if(testType == "GLM"){
fit <- glmFit(dge)
de <- glmLRT(fit)
}
# 5. Extract DE results
tt = topTags(de, n = nrow(dge), sort.by	= "none")
if(ncol(tt$table)>4){
res <- tt$table[,-3]
} else{
res <- tt$table
}
## 5.Extract normalized  CPMs
nc = cpm(dge, normalized.lib.sizes = TRUE)
normCounts <- as.data.frame(nc)
## 6. List with DE results and normalized counts
deList <- list(res, normCounts)
return(deList)
}
deLimma <- function(readCounts, meta, normMethod) {
countTable  <- readCounts[, -1]
rownames(countTable) <- readCounts[, 1]
samplescondition <- factor(meta$treatment)
d  <- DGEList(countTable, group = samplescondition)
d <- calcNormFactors(d, method = normMethod)
v <- voom(d, plot = FALSE)
fit <- lmFit(v)
ebayes.fit <- eBayes(fit)
if(length(levels(as.factor(meta$treatment))) == 2){
tab <-
topTable(
ebayes.fit,
coef = 2,
number = dim(ebayes.fit)[1],
genelist = fit$genes$NAME,
adjust = "fdr",
sort.by = "none"
)
res <-data.frame(tab$logFC, tab$t, tab$P.Value, tab$adj.P.Val)
colnames(res) <- c("logFC", "t", "Pvalue", "FDR")
}else{
tab <-
topTable(
ebayes.fit,
coef = 1:length(levels(as.factor(meta$treatment))),
number = dim(ebayes.fit)[1],
genelist = fit$genes$NAME,
adjust = "fdr",
sort.by = "none"
)
res <-data.frame(tab[,1], tab$F, tab$P.Value, tab$adj.P.Val)
colnames(res) <- c("logFC", "F", "Pvalue", "FDR")
}
row.names(res) <- row.names(tab)
deList <- list(res, v$E)
return(deList)
}
filterFunction <- function(data, method, value, sampleNo) {
countTable  <- data[, -1]
rownames(countTable) <- data[, 1]
#filter by CPM
if (method == 1) {
keep <- rowSums(edgeR::cpm.default(countTable) > value) >= sampleNo
countTable <- countTable[keep, ]
#filter by Median
} else if (method == 2) {
countTable <-
subset(countTable, apply(countTable, 1, median) >= value)
#filter by Max
} else if (method == 3) {
countTable <- subset(countTable, apply(countTable, 1, max) >= value)
}
IDs <- rownames(countTable)
rownames(countTable) <- NULL
countTable <- cbind(IDs, countTable)
return(countTable)
}
meta <- read.table("C:/Report/batchEffect/olf_meta.txt", header = T)
xx <- read.table("C:/Report/batchEffect/olf_counts_2.txt", header = T, row.names = NULL)
meta <- read.table("C:/Report/batchEffect/olf_meta.txt", header = T)
head(xx)
meta
readCounts <- filterFunction(xx, 1, 1, 4)
# DESeq2
de_DESeq2 <- deSequence(readCounts, meta, "LRT", "parametric")
head(de_DESeq2[[1]])
head(de_DESeq2[[2]])
# DESeq2
de_DESeq2 <- deSequence(readCounts, meta, "Wald", "parametric")
head(xx)
meta
head(de_DESeq2[[1]])
head(de_DESeq2[[2]])
head(de_DESeq2[[1]])
# EdgeR
de_edgeR <- deEdgeR(readCounts, meta, "GLM", "TMMwsp")
head(de_edgeR[[1]])
# limma
de_limma <- deLimma(readCounts, meta, "none")
head(de_limma[[1]])
deLimma <- function(readCounts, meta, normMethod) {
countTable  <- readCounts[, -1]
rownames(countTable) <- readCounts[, 1]
samplescondition <- factor(meta$treatment)
d  <- DGEList(countTable, group = samplescondition)
d <- calcNormFactors(d, method = normMethod)
v <- voom(d, plot = FALSE)
fit <- lmFit(v)
ebayes.fit <- eBayes(fit)
if(length(levels(as.factor(meta$treatment))) > 2){
tab <-
topTable(
ebayes.fit,
coef = 2,
number = dim(ebayes.fit)[1],
genelist = fit$genes$NAME,
adjust = "fdr",
sort.by = "none"
)
res <-data.frame(tab$logFC, tab$t, tab$P.Value, tab$adj.P.Val)
colnames(res) <- c("logFC", "t", "Pvalue", "FDR")
}else{
tab <-
topTable(
ebayes.fit,
coef = 1:length(levels(as.factor(meta$treatment))),
number = dim(ebayes.fit)[1],
genelist = fit$genes$NAME,
adjust = "fdr",
sort.by = "none"
)
res <-data.frame(tab[,1], tab$F, tab$P.Value, tab$adj.P.Val)
colnames(res) <- c("logFC", "F", "Pvalue", "FDR")
}
row.names(res) <- row.names(tab)
deList <- list(res, v$E)
return(deList)
}
# limma
de_limma <- deLimma(readCounts, meta, "none")
head(de_limma[[1]])
# limma
de_limma <- deLimma(readCounts, meta, "TMMwsp")
head(de_limma[[1]])
deLimma <- function(readCounts, meta, normMethod) {
countTable  <- readCounts[, -1]
rownames(countTable) <- readCounts[, 1]
samplescondition <- factor(meta$treatment)
d  <- DGEList(countTable, group = samplescondition)
d <- calcNormFactors(d, method = normMethod)
v <- voom(d, plot = FALSE)
fit <- lmFit(v)
ebayes.fit <- eBayes(fit)
if(length(levels(as.factor(meta$treatment))) > 2){
tab <-
topTable(
ebayes.fit,
coef = 3,
number = dim(ebayes.fit)[1],
genelist = fit$genes$NAME,
adjust = "fdr",
sort.by = "none"
)
res <-data.frame(tab$logFC, tab$t, tab$P.Value, tab$adj.P.Val)
colnames(res) <- c("logFC", "t", "Pvalue", "FDR")
}else{
tab <-
topTable(
ebayes.fit,
coef = 1:length(levels(as.factor(meta$treatment))),
number = dim(ebayes.fit)[1],
genelist = fit$genes$NAME,
adjust = "fdr",
sort.by = "none"
)
res <-data.frame(tab[,1], tab$F, tab$P.Value, tab$adj.P.Val)
colnames(res) <- c("logFC", "F", "Pvalue", "FDR")
}
row.names(res) <- row.names(tab)
deList <- list(res, v$E)
return(deList)
}
# limma
de_limma <- deLimma(readCounts, meta, "TMMwsp")
head(de_limma[[1]])
head(de_limma[[2]])
deLimma <- function(readCounts, meta, normMethod) {
countTable  <- readCounts[, -1]
rownames(countTable) <- readCounts[, 1]
samplescondition <- factor(meta$treatment)
d  <- DGEList(countTable, group = samplescondition)
d <- calcNormFactors(d, method = normMethod)
v <- voom(d, plot = FALSE)
fit <- lmFit(v)
ebayes.fit <- eBayes(fit)
if(length(levels(as.factor(meta$treatment))) == 2){
tab <-
topTable(
ebayes.fit,
coef = 2,
number = dim(ebayes.fit)[1],
genelist = fit$genes$NAME,
adjust = "fdr",
sort.by = "none"
)
res <-data.frame(tab$logFC, tab$t, tab$P.Value, tab$adj.P.Val)
colnames(res) <- c("logFC", "t", "Pvalue", "FDR")
}else{
tab <-
topTable(
ebayes.fit,
coef = 1:length(levels(as.factor(meta$treatment))),
number = dim(ebayes.fit)[1],
genelist = fit$genes$NAME,
adjust = "BH",
sort.by = "none"
)
res <-data.frame(tab[,1], tab$F, tab$P.Value, tab$adj.P.Val)
colnames(res) <- c("logFC", "F", "Pvalue", "FDR")
}
row.names(res) <- row.names(tab)
deList <- list(res, v$E)
return(deList)
}
xx <- read.table("C:/Report/batchEffect/olf_counts_2.txt", header = T, row.names = NULL)
meta <- read.table("C:/Report/batchEffect/olf_meta.txt", header = T)
head(xx)
meta
readCounts <- filterFunction(xx, 1, 1, 4)
# DESeq2
de_DESeq2 <- deSequence(readCounts, meta, "Wald", "parametric")
# limma
de_limma <- deLimma(readCounts, meta, "TMMwsp")
head(de_limma[[1]])
head(de_limma[[2]])
deLimma <- function(readCounts, meta, normMethod) {
countTable  <- readCounts[, -1]
rownames(countTable) <- readCounts[, 1]
samplescondition <- factor(meta$treatment)
d  <- DGEList(countTable, group = samplescondition)
d <- calcNormFactors(d, method = normMethod)
v <- voom(d, plot = FALSE)
fit <- lmFit(v)
ebayes.fit <- eBayes(fit)
# if(length(levels(as.factor(meta$treatment))) == 2){
tab <-
topTable(
ebayes.fit,
coef = 2,
number = dim(ebayes.fit)[1],
genelist = fit$genes$NAME,
adjust = "fdr",
sort.by = "none"
)
res <-data.frame(tab$logFC, tab$t, tab$P.Value, tab$adj.P.Val)
colnames(res) <- c("logFC", "t", "Pvalue", "FDR")
# }else{
#   tab <-
#     topTable(
#       ebayes.fit,
#       coef = 1:length(levels(as.factor(meta$treatment))),
#       number = dim(ebayes.fit)[1],
#       genelist = fit$genes$NAME,
#       adjust = "BH",
#       sort.by = "none"
#     )
#
#   res <-data.frame(tab[,1], tab$F, tab$P.Value, tab$adj.P.Val)
#   colnames(res) <- c("logFC", "F", "Pvalue", "FDR")
# }
row.names(res) <- row.names(tab)
deList <- list(res, v$E)
return(deList)
}
# limma
de_limma <- deLimma(readCounts, meta, "TMMwsp")
head(de_limma[[1]])
devtools::load_all(".")
head(de_limma[[1]])
startBingleSeq()
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
xx <- read.table("C:/Report/batchEffect/olf_counts_2.txt", header = T, row.names = NULL)
yy <- read.table("C:/Report/batchEffect/olf_meta.txt", header = T)
head(xx)
head(yy)
#' Harman Batch Effect Correction
#'
#' @param counts, Filtered Count Table
#' @param meta, Metadata Table
#'
#' @export
#' @return Returns batch-effect corrected table
batchHarman <- function(counts, meta, session){
out <- tryCatch(
{
countTable  <- counts[, -1]
rownames(countTable) <- counts[, 1]
harman_results <- harman(countTable, meta$treatment, meta$batch, limit=0.95)
harman_corr <- reconstructData(harman_results)
harman_corr[harman_corr<0] <- 0
out <- harman_corr
},
error=function(cond) {
sendSweetAlert(
session = session,
title = "Batch Effect Correction Error",
text = "Please ensure that the metadata table is in the correct format.",
type = "error"
)
return(NA)
}
)
return(out)
}
batchComBat <- function(counts, meta, session){
out <- tryCatch(
{
countTable  <- counts[, -1]
rownames(countTable) <- counts[, 1]
design <- model.matrix(~as.factor(treatment), data=meta)
out = ComBat(as.matrix(countTable), batch=meta$batch, mod=design)
},
error=function(cond) {
sendSweetAlert(
session = session,
title = "Batch Effect Correction Error",
text = "Please ensure that the metadata table is in the correct format.",
type = "error"
)
return(NA)
}
)
return(out)
}
counts <- counts
counts <- counts
meta <- yy
countTable  <- counts[, -1]
rownames(countTable) <- counts[, 1]
head(counts)
counts <- xx
meta <- yy
countTable  <- counts[, -1]
head(counts)
head(counts)
countTable  <- counts[, -1]
rownames(countTable) <- counts[, 1]
head(countTable)
harman_results <- harman(countTable, meta$treatment, meta$batch, limit=0.95)
harman_corr <- reconstructData(harman_results)
harman_corr[harman_corr<0] <- 0
out <- harman_corr
head(out)
IDs <- rownames(harman_corr)
rownames(harman_corr) <- NULL
countTable <- cbind(IDs, harman_corr)
head(countTable)
countTable <- as.dataframe(cbind(IDs, harman_corr))
countTable <- as.data.frame(cbind(IDs, harman_corr))
head(countTable)
xx <- read.table("C:/Report/batchEffect/olf_counts_2.txt", header = T, row.names = NULL)
yy <- read.table("C:/Report/batchEffect/olf_meta.txt", header = T)
head(xx)
head(yy)
counts <- xx
meta <- yy
head(counts)
countTable  <- counts[, -1]
rownames(countTable) <- counts[, 1]
head(countTable)
harman_results <- harman(countTable, meta$treatment, meta$batch, limit=0.95)
harman_corr <- reconstructData(harman_results)
harman_corr[harman_corr<0] <- 0
head(out)
IDs <- rownames(harman_corr)
out <- as.data.frame(cbind(IDs, harman_corr))
rownames(out) <- NULL
head(out)
IDs <- rownames(harman_corr)
rownames(harman_corr) <- NULL
out <- as.data.frame(cbind(IDs, harman_corr))
head(out)
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
startBingleSeq()
startBingleSeq()
startBingleSeq()
