devtools::load_all(".")
library(shiny)
library(shinyjs)
library(shinyFiles)
library(shinyWidgets)
library(V8) # enables js lines to be read intext
library(dplyr)
library(DT)
library(grDevices)
library(ggplot2)
library(VennDiagram)
library(factoextra)
library(fastcluster)
library(reshape2)
library(gridExtra)
library(ggrepel)
library(DESeq2)
library(edgeR)
library(limma)
library(ALDEx2)
library("MAST")
# Load required SC packages
library(monocle)
library(Seurat)
library('scran')
library('SC3')
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
library(BingleSeq)
BingleSeq::startBingleSeq()
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
library(BingleSeq)
#' Launch the application
#'
#' #' Launches the app
#'
#' @import shiny
#' @import shinyjs
#' @import shinyFiles
#' @import shinyWidgets
#' @import V8
#' @import DT
#' @import grDevices
#' @import ggplot2
#' @import VennDiagram
#' @import factoextra
#' @import fastcluster
#' @import reshape2
#' @import gridExtra
#' @import ggrepel
#' @import DESeq2
#' @import edgeR
#' @import limma
#' @import ALDEx2
#' @import MAST
#' @import monocle
#' @import Seurat
#' @import scran
#' @import SC3
#'
#' @include server.R
#' @include ui.R
#'
#' @export
#' @return None
startBingleSeq <- function(){
if (interactive()) {
# Load packages
library(shiny)
library(shinyjs)
library(shinyFiles)
library(shinyWidgets)
library(V8) # enables js lines to be read intext
library(dplyr)
library(DT)
library(grDevices)
library(ggplot2)
library(VennDiagram)
library(factoextra)
library(fastcluster)
library(reshape2)
library(gridExtra)
library(ggrepel)
library(DESeq2)
library(edgeR)
library(limma)
library(ALDEx2)
library("MAST")
# Load required SC packages
library(monocle)
library(Seurat)
library('scran')
library('SC3')
# library(goseq)
# library(org.Mm.eg.db)
# library(org.Hs.eg.db)
# library(GO.db)
app <- shinyApp(ui = shinyUI(ui),
server = shinyServer(server))
runApp(app)
}
}
startBingleSeq()
devtools::load_all(".")
library(BingleSeq)
devtools::load_all(".")
devtools::load_all(".")
library(BingleSeq)
BingleSeq::startBingleSeq()
#' DESeq2 Differential Expression Pipeline
#'
#' @param readCounts The filtered CountTable
#' @param conditionNo The number of Conditions
#' @param replicateNo The number of Replicates
#'
#' @export
#' @return The results of from the differential expression table
deSequence <- function(readCounts, conditionNo, replicateNo){
## 2. Format Count dataframe
output2 <-readCounts[,-1]
rownames(output2)<- readCounts[,1]
# Create Name vectors for conditions
if(conditionNo==2){
samplescondition<-c(rep("C1",replicateNo),rep("C2",replicateNo))
print(samplescondition)
} else if(conditionNo==3){
samplescondition<-c(rep("C1",replicateNo),rep("C2",replicateNo), rep("C3",replicateNo))
print(samplescondition)
}
# Create a coldata frame
coldata <- data.frame(row.names=colnames(output2), samplescondition)
# Initialize DESeqDataSet Object
dds <- DESeqDataSetFromMatrix(countData=output2, colData=coldata, design=~samplescondition)
print(nrow(output2))
## 3. Run the DESeq pipeline on the DESeq object
if(conditionNo==2){
dds <- DESeq(dds)
res <- results(dds, contrast=c("samplescondition","C2","C1"))   ## Extract A vs B contrast results
# Convert to a data-frame and make sure it matches EdgeR output
DEData <- data.frame(as.data.frame(res))
print(nrow(DEData))
DEData.matching <- DEData[,c(2,4:6)]
colnames(DEData.matching) <- c("logFC", "stat", "Pvalue", "FDR")
} else{
# ANOVA
dds = DESeq(dds, test = "LRT", reduced=~1)
res <- results(dds)
AvB <- results(dds, contrast=c("samplescondition","C2","C1"), test="Wald")
BvC <- results(dds, contrast=c("samplescondition","C3","C2"), test="Wald")
head(res)
nrow(res)
res$log2FC_AvB <- AvB$log2FoldChange
res$log2FC_BvC <- BvC$log2FoldChange
DEData.matching <- res[,c(7,8,2:6)]
colnames(DEData.matching) <- c("logFC_C2vC1","logFC_C3vC2","logFC_C3vC1","lfcSE", "stat", "Pvalue", "FDR")
DEData.matching <- data.frame(as.data.frame(DEData.matching))
}
## 5. Write NormalizedCounts and MasterFile
# Write normalised read counts
resdata <- as.data.frame(counts(dds, normalized=TRUE))
# write.csv(resdata, file="output/normalizedCounts.csv", quote = FALSE)
masterFileDE <- merge(DEData.matching,resdata, by="row.names", all.x=TRUE)
# write.csv(masterFileDE, file="output/DESeq2_DE_output.csv", row.names = FALSE)
format.data.frame(masterFileDE, digits=4)
countTable <- masterFileDE[,-1]
rownames(countTable)<- masterFileDE[,1]
return(countTable)
}
data <- read.csv("D:/2.MscThesis/de_app/temp/masterFile.csv", row.names = 1)
head(data)
x <- deSequence(data, 3, 4)
x <- deSequence(data, 2, 3)
data <- read.csv("D:/000000000000000000000000000000000000000000000000/gene_count_matrix.csv", row.names = 1)
head(data)
x <- deSequence(data, 2, 3)
data <- read.csv("D:/000000000000000000000000000000000000000000000000/gene_count_matrix.csv")
head(data)
x <- deSequence(data, 2, 3)
x <- deSequence(data, 3, 4)
#' @param offset The last column of DE results
#' @param replicates The number of replicates
#' @param geneNo The number of genes to be displayed
#' @param type Filter by up-, down-, or absolute significe DE
#' @param pvalue P-value threshold
#' @param fchange Fold-Change threshold
#' @param conditionFC The Fold-change column of the condition of interest
#' @param names Boolean - whether to show names or not
#' @export
#' @return The heatmap
plotHeatmapTop <- function(data, offset, replicates, geneNo, type, pvalue, fchange, conditionFC, names){
table <- data
fchange <- log2(fchange) # convert to log2
# save appropriate columns
if(conditionFC==1){
columns = (offset+1):((offset) + 2*replicates) #AvB
} else if(conditionFC==2){
columns = ((offset+1)+replicates):((offset) + 3*replicates) #BvC
} else if(conditionFC==3){
columns = c((offset+1):(offset+replicates), ((offset+1)+ 2*replicates):((offset) + 3*replicates)) #AvC
} else{
conditionFC = c(1,2,3)
columns = ((offset)+1):(ncol(table))
}
#filter
if(type==1){
table <- subset(table,FDR < pvalue & abs(table[,conditionFC]) > fchange) # absSig
}else if(type==2){
table <- subset(table,FDR < pvalue & table[,conditionFC] > fchange) # upregSig
}else if(type==3){
table <- subset(table,FDR < pvalue & table[,conditionFC] < -fchange) # downreg Sig
}else if(type==4){
table <- subset(table,FDR > pvalue | abs(table[,conditionFC]) < fchange) # non-Sig
}
table <- table[order(table$FDR),] # order by FDR
table <- table[1:geneNo,]
table <- na.omit(table) # omit NANs
counts <- table[,columns]   # Select  expression value columns
counts.scaled <- t(scale(t(counts)))  # Convert FPKM to Z-scores
row.order <- hclust(dist(counts.scaled), method="average")$order # Cluster the data
counts.scaled.clustered <- counts.scaled[row.order,] # Order by row.order
counts.scaled.clustered.m <- melt(as.matrix(counts.scaled.clustered)) # convert to ggplot-appropriate format
hm.palette <- colorRampPalette(c("red", "white", "blue")) # Set the colour range
plot <- ggplot(counts.scaled.clustered.m, aes(x = Var2, y = Var1, fill = value)) +
geom_tile() +  scale_fill_gradientn(colours = hm.palette(100), name="Row Z-score")+
ylab('Genes') + xlab('Samples') + theme_bw() +
theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 12),axis.title=element_text(size=14),
axis.ticks=element_blank(), plot.background = element_blank(),panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),panel.border = element_blank())
if(!names){
plot <- plot + theme(axis.text.y = element_blank())
}
return(plot)
}
plotHeatmapTop(x, 8, 4, 30, 1, 0.05, 2, 1, TRUE)
head(data)
#' Filter Function
#'
#' @param countTable The loaded Count Table
#'
#' @export
#' @return countTable The filtered Count Table
filterFunction <- function(countTable, method, value){
output <- countTable
countTable  <- output [,-1]
head(countTable)
#filter by CPM
if(method==1){
keep <- rowSums(edgeR::cpm.default(countTable)>1)>= value
countTable <- countTable[keep,]
#filter by Median
}else if(method==2){
countTable <- subset(countTable, apply(countTable, 1, median) >= value)
#filter by Max
}else if(method==3){
countTable <- subset(countTable, apply(countTable, 1, max) >= value)
}
# add gene IDs as first column
d <- countTable
IDs <- rownames(countTable)
rownames(d) <- NULL
countTable <- cbind(IDs,d)
# write.csv(countTable, file="output/filtered_Data.csv", row.names = FALSE)
return(countTable)
}
filter <- filterFunction(data, 1, 5)
x <- deSequence(filter, 3, 4)
plotHeatmapTop(x, 8, 4, 30, 1, 0.05, 2, 1, TRUE)
countTable <- data
output <- countTable
countTable  <- output [,-1]
head(countTable)
countTable <- data
output <- countTable
countTable  <- output [,-1]
keep <- rowSums(edgeR::cpm.default(countTable)>1)>= value
head(countTable)
countTable <- data
output <- countTable
countTable  <- output[,-1]
head(countTable)
countTable <- data
head(countTable)
output <- countTable
countTable  <- output[,-1]
head(countTable)
IDs <- rownames(output)
rownames(countTable) <- NULL
countTable <- cbind(IDs,countTable)
head(countTable)
rownames(countTable) <- rownames(data)
countTable  <- output[,-1]
head(countTable)
#delete
countTable <- data
#delete
countTable <- data
output <- countTable
rownames(countTable) <- rownames[,1]
countTable  <- output[,-1]
head(countTable)
#delete
countTable <- data
output <- countTable
rownames(countTable) <- data[,1]
countTable  <- output[,-1]
head(countTable)
#delete
countTable <- data
output <- countTable
rownames(countTable) <- data[,1]
countTable  <- output[,-1]
#delete
countTable <- data
output <- countTable
countTable  <- output[,-1]
rownames(countTable) <- data[,1]
head(countTable)
value = 5
keep <- rowSums(edgeR::cpm.default(countTable)>1)>= value
countTable <- countTable[keep,]
IDs <- rownames(countTable)
rownames(countTable) <- NULL
countTable <- cbind(IDs,countTable)
head(countTable)
countTable  <- data[,-1]
rownames(countTable) <- data[,1]
head(countTable)
keep <- rowSums(edgeR::cpm.default(countTable)>1)>= value
countTable <- countTable[keep,]
IDs <- rownames(countTable)
rownames(countTable) <- NULL
countTable <- cbind(IDs,countTable)
head(countTable)
#' Filter Function
#'
#' @param countTable The loaded Count Table
#' @param method Filter Option (CPM, MAX, Median)
#' @param value Keep only genes with counts > than this value
#'
#' @export
#' @return countTable The filtered Count Table
filterFunction <- function(data, method, value){
countTable  <- data[,-1]
rownames(countTable) <- data[,1]
head(countTable)
#filter by CPM
if(method==1){
keep <- rowSums(edgeR::cpm.default(countTable)>1)>= value
countTable <- countTable[keep,]
#filter by Median
}else if(method==2){
countTable <- subset(countTable, apply(countTable, 1, median) >= value)
#filter by Max
}else if(method==3){
countTable <- subset(countTable, apply(countTable, 1, max) >= value)
}
# add gene IDs as first column
IDs <- rownames(countTable)
rownames(countTable) <- NULL
countTable <- cbind(IDs,countTable)
head(countTable)
# write.csv(countTable, file="output/filtered_Data.csv", row.names = FALSE)
return(countTable)
}
data <- read.csv("D:/000000000000000000000000000000000000000000000000/gene_count_matrix.csv")
head(data)
filter <- filterFunction(data, 1, 5)
x <- deSequence(filter, 3, 4)
plotHeatmapTop(x, 8, 4, 30, 1, 0.05, 2, 1, TRUE)
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
startBingleSeq()
startBingleSeq()
devtools::load_all(".")
devtools::load_all(".")
startBingleSeq()
#' Generate Summary
#'
#' Generates a summary of the columns(samples) in the Count Table
#'
#' @export
#' @return df a dataframe containing the summary
generateSummary <- function(counts){
countTable  <- counts[,-1]
rownames(countTable)<- counts[,1]
x1 <- vector()
x2 <- vector()
colSums(countTable[])
for(i in 1:ncol(countTable)){
x1[i] <-  colnames(countTable)[i]
x2[i] <- colSums(countTable[i])
}
x1[ncol(countTable)+1] <- "Total"
x2[ncol(countTable)+1] <- sum(x2)
x1[ncol(countTable)+2] <- "Median"
x2[ncol(countTable)+2] <- median(x2)
x1[ncol(countTable)+3] <- "Genes#"
x2[ncol(countTable)+3] <- nrow(countTable)
df <- data.frame(x1,x2)
format.data.frame(df, big.mark=",")
colnames(df) <- c("Sample", "Counts")
# write.csv(df, file="output/Data_Summary.csv", row.names = FALSE)
return(df)
}
data <- read.table("Pb.readcounts.txt")
data <- read.table("D:/000000000000000000000000000000000000000000000000/Pb.readcounts.txt")
head(data)
generateSummary(data)
countTable <- read.table("D:/000000000000000000000000000000000000000000000000/Pb.readcounts.txt")
for(i in 1:ncol(countTable)){
x1[i] <-  colnames(countTable)[i]
x2[i] <- colSums(countTable[i])
}
x1 <- vector()
x2 <- vector()
colSums(countTable[])
countTable <- read.csv("D:/000000000000000000000000000000000000000000000000/gene_count_matrix.csv")
colSums(countTable[])
countTable  <- counts[,-1]
rownames(countTable)<- counts[,1]
data <- read.csv("D:/000000000000000000000000000000000000000000000000/gene_count_matrix.csv")
data <- read.table("D:/000000000000000000000000000000000000000000000000/Pb.readcounts.txt")
data <- read.table("D:/000000000000000000000000000000000000000000000000/Pb.readcounts.txt")
head(data)
generateSummary(data)
countTable  <- data[,-1]
rownames(countTable)<- data[,1]
colSums(countTable[])
data <- read.csv("D:/000000000000000000000000000000000000000000000000/gene_count_matrix.csv")
head(data)
generateSummary(data)
countTable  <- data[,-1]
rownames(countTable)<- data[,1]
colSums(countTable[])
x1 <- vector()
x2 <- vector()
colSums(countTable[])
for(i in 1:ncol(countTable)){
x1[i] <-  colnames(countTable)[i]
x2[i] <- colSums(countTable[i])
}
x1[ncol(countTable)+1] <- "Total"
x2[ncol(countTable)+1] <- sum(x2)
x1[ncol(countTable)+2] <- "Median"
x2[ncol(countTable)+2] <- median(x2)
x1[ncol(countTable)+3] <- "Genes#"
x2[ncol(countTable)+3] <- nrow(countTable)
df <- data.frame(x1,x2)
format.data.frame(df, big.mark=",")
colnames(df) <- c("Sample", "Counts")
head(df)
df
data <- read.csv("D:/000000000000000000000000000000000000000000000000/gene_count_matrix.csv")
head(data)
data <- read.table("D:/000000000000000000000000000000000000000000000000/Pb.readcounts.txt")
head(data[,1:6])
countTable  <- data[,-1]
rownames(countTable)<- data[,1]
head(countTable[,1:6])
devtools::load_all(".")
startBingleSeq()
startBingleSeq()
devtools::load_all(".")
devtools::load_all(".")
startBingleSeq()
startBingleSeq()
startBingleSeq()
devtools::load_all(".")
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
devtools::load_all(".")
startBingleSeq()
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
devtools::load_all(".")
startBingleSeq()
devtools::load_all(".")
startBingleSeq()
startBingleSeq()
